# String

В этой задаче вам нужно реализовать класс динамически расширяющейся строки. 
Проблема стековых и выделяемых в куче строк заключается в том, что они имеют фиксированный размер 
и не умеют автоматически расширяться при необходимости (в отличие, например, от `str` в Python). 
Кроме того, при выделении памяти в динамической области возникает потребность в 
ручном отслеживании возможных утечек памяти, что накладывает дополнительные сложности на процесс разработки.

Эти проблемы можно обойти, используя ООП функционал C++. В частности, механизм 
инкапсуляции позволяет реализовать методы добавления элементов, при вызове которых 
строка будет автоматически расширяться, создавая иллюзию неограниченного контейнера. 
А механизмы работы с ресурсами гарантируют своевременное выделение и очищение памяти.

Здесь естественным образом возникает разделение понятий "размера" строке (size) и 
ее "вместимости" (capacity). С++ в каждый момент времени позволяет поддерживать 
массивы конечной вместимости, при этом фактический размер (количество добавленных элементов) 
может быть меньше этого значения. 
*Почему бы постоянно не поддерживать равенство между этими величинами?* - это не эффективно. 
Допустим, мы добавляем элементы по одному. Тогда при каждом обновлении будет 
происходить перевыделение исходной памяти с последующим копированием всех старых элементов в новый буфер. 
Легко видеть, что в этом случае общее число копирований будет квадратичным образом зависеть от числа добавленных элементов. 
Оказыватся, что, если при каждом переполнении массива увеличивать его вместимость 
в константное число раз, то можно добиться линейной зависимости числа операций над 
массивом от числа добавляемых элементов (https://en.wikipedia.org/wiki/Dynamic_array#Geometric_expansion_and_amortized_cost). 
В вашем решении будет проверяться корректность работы данной схемы при множителе 
равном 2 (то есть, если фактический размер изменяется так: 0 -> 1 -> 2 -> 3 -> 4 -> 5 -> ..., то 
вместимость меняется следующим образом: 0 -> 1 -> 2 -> 4 -> 4 -> 8 -> ...).

## Детали реализации

От вас требуется реализовать класс `String` - упрощенный аналог `std::string`. 
Класс должен поддерживать следующий функционал:
* Конструктор по умолчанию - создает пустую строку, никакой памяти не выделяется!
* Конструктор, принимающий `size` и `character` (именно в этом порядке) - создает строку длины `size`, 
заполненный символами `character`
* Конструктор от `const char*`, для того, чтобы узнать длину C-style строки, используйте функцию `strlen`
* Конструктор копирования
* Деструктор
* Метод `Clear()` - устанавливает размер в 0, деаллокации выделенной памяти при этом НЕ происходит
* Метод `PushBack(character)` - добавляет букву `character` в конец строки
* Метод `PopBack()` - удаляет последнюю букву. В случае пустой строки должен 
ничего не делать, хотя для `std::string` это будет UB
* Метод `Resize(new_size)` - изменяет размер на `new_size`. Если вместимость 
не позволяет хранить столько символов, то выделяется новый буфер с вместимостью `new_size`.
* Метод `Resize(new_size, character)` - то же, что и `Resize(new_size)`, но в случае `new_size > size` 
заполняет недостающие элементы значением `character`.
* Метод `Reserve(new_cap)` - изменяет вместимость на `max(new_cap, текущая вместимость)` 
(если new_cap <= текущая вместимость, то делать ничего не нужно). Размер при этом не изменяется.
* Метод `ShrinkToFit()` - уменьшает `capacity` до `size` (если `capacity` > `size`)
* Метод `Swap(other)` - обменивает содержимое с другой строкой `other`. Должен работать за O(1)
* Методы `Front()` и `Back()` - доступ к первому и последнему символам (тоже по две версии).
* Метод `Empty()` - `true`, если строка пустая (размер 0)
* Метод `Size()` - возвращает размер
* Метод `Capacity()` - возвращает вместимость
* Метод `Data()` - возвращает указатель на начало массива.

* Метод `std::vector<String> Split(const String& delim = " ")` - аналог сплита в питоне.

## Примечания

1. Решение должно состоять из двух файлов: `string.hpp` с объявлением класса и его методов и `string.cpp` с определением всего необходимого.

2. В этой задаче запрещается использование стандартной библиотеки C++ кроме как `std::vector` только для `Split`. Если нужны какие-либо служебные классы или функции, реализуйте их самостоятельно.

3. Проверка устроена таким образом, что требует от вас жесткого следования принятым (выше) 
сигнатурам и именованиям сущностей (то есть никакие `MyString`, `__string_`, `push_back`, `superSolver3000` не пройдут). 
Если вы реализовали требуемый функционал не полностью или интерфейс отличается от заявленного, 
в ответ вы получите ошибку компиляции.
